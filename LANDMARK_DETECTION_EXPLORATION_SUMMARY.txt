================================================================================
S1 FACE MIRROR - LANDMARK DETECTION IMPLEMENTATION EXPLORATION
================================================================================

GENERATED: 2025-11-04
SYSTEM: Apple Silicon macOS
LOCATION: /Users/johnwilsoniv/Documents/SplitFace Open3/S1 Face Mirror/

================================================================================
EXECUTIVE SUMMARY
================================================================================

The S1 Face Mirror application implements a complete 68-point facial landmark
detection pipeline using PyFaceAU (pure Python backend). The system detects
faces, extracts 68 facial landmarks, optionally refines them with CLNF,
applies temporal smoothing, and uses the landmarks to create anatomically
accurate mirrored face videos.

KEY STATS:
- 68-point landmark system (dlib standard)
- PFLD detector (4.37% NME accuracy)
- RetinaFace detector for face detection
- Optional SVR-based CLNF refinement (~1-2ms per frame)
- Fallback OpenFace-quality CLNF for poor-quality frames
- 5-frame temporal smoothing with weighted averaging
- ~14-28 FPS processing on Apple Silicon

================================================================================
CORE FILES IDENTIFIED
================================================================================

PRIMARY (LANDMARK DETECTION):
├─ pyfaceau_detector.py (605 lines)
│  └─ PyFaceAU68LandmarkDetector class
│     ├─ get_face_mesh() - Main detection entry point [Lines 270-426]
│     ├─ get_facial_midline() - Calculate glabella & chin [Lines 428-471]
│     ├─ calculate_head_pose() - Head yaw estimation [Lines 473-543]
│     ├─ check_landmark_quality() - Validation [Lines 186-245]
│     └─ reset_tracking_history() - Clear temporal state [Lines 172-184]

SECONDARY (INTEGRATION):
├─ face_splitter.py (91 lines)
│  └─ StableFaceSplitter - Pipeline orchestrator
│     ├─ Creates PyFaceAU68LandmarkDetector
│     ├─ Creates FaceMirror
│     └─ Creates VideoProcessor

├─ video_processor.py (635 lines)
│  └─ VideoProcessor
│     ├─ process_video() - Main processing orchestration
│     └─ _process_frame_batch() - Frame processing loop [Lines 203-238]

├─ face_mirror.py (185 lines)
│  └─ FaceMirror
│     ├─ create_mirrored_faces() - Apply mirroring [Lines 12-106]
│     └─ create_debug_frame() - Debug visualization [Lines 108-185]

TERTIARY (SUPPORTING):
├─ main.py - Application entry point (line 763)
├─ config.py - Configuration settings
├─ config_paths.py - Model paths
└─ openface_integration.py - AU extraction wrapper

================================================================================
MODELS & FRAMEWORKS
================================================================================

FACE DETECTION:
├─ RetinaFace (ONNXRetinaFaceDetector)
│  ├─ File: weights/retinaface_mobilenet025_coreml.onnx (1.73 MB)
│  ├─ Framework: ONNX + CoreML acceleration
│  ├─ Usage: Frame 0 only (cached in subsequent frames)
│  ├─ Speed: ~30ms per detection
│  └─ Purpose: Get face bounding box

LANDMARK DETECTION:
├─ PFLD (CunjianPFLDDetector)
│  ├─ File: weights/pfld_cunjian.onnx (2.99 MB)
│  ├─ Framework: ONNX + CoreML acceleration
│  ├─ Accuracy: 4.37% NME
│  ├─ Usage: Every frame
│  ├─ Speed: ~5-10ms per frame
│  └─ Output: 68-point coordinates (dlib standard)

LANDMARK REFINEMENT:
├─ SVR-based CLNF (TargetedCLNFRefiner)
│  ├─ File: weights/svr_patches_0.25_general.txt (1.13 MB)
│  ├─ Framework: SVR patch experts
│  ├─ Usage: Every frame (default enabled)
│  ├─ Speed: ~1-2ms per frame
│  └─ Purpose: Improve PFLD accuracy

├─ OpenFace-Quality CLNF (CLNFDetector) - FALLBACK
│  ├─ Directory: weights/clnf/
│  ├─ Framework: PyTorch optimization-based
│  ├─ Usage: Only poor-quality landmarks
│  ├─ Speed: ~200-500ms per frame (very slow)
│  └─ Purpose: High-accuracy refinement for surgical markings, paralysis

SUPPORTING MODELS:
├─ Shape Model: weights/In-the-wild_aligned_PDM_68.txt (69 KB)
│  └─ 3D shape priors (not currently enforced)

================================================================================
LANDMARK SYSTEM
================================================================================

68-POINT DLIB STANDARD INDEXING:
├─ Jaw: Indices 0-16 (17 points around jawline)
├─ Eyebrows: Indices 17-26 (5 left + 5 right)
├─ Nose: Indices 27-35 (9 points)
├─ Eyes: Indices 36-47 (6 left + 6 right)
└─ Mouth: Indices 48-67 (20 points)

CRITICAL INDICES FOR MIRRORING:
├─ Index 8: Chin center (anatomical anchor point)
├─ Index 21: Left medial eyebrow (for glabella calculation)
└─ Index 22: Right medial eyebrow (for glabella calculation)

MIDLINE CALCULATION (get_facial_midline):
├─ Glabella = (landmark[21] + landmark[22]) / 2
│  └─ Point between eyebrows (used for anatomical centering)
├─ Chin = landmark[8]
│  └─ Center chin point (used as lower anchor)
└─ Direction vector = chin - glabella
   └─ Used for reflection calculations

================================================================================
DATA FLOW SUMMARY
================================================================================

FRAME PROCESSING FLOW:
1. VideoProcessor._process_frame_batch()
   ├─ Read: frame (BGR image)
   ├─ Call: detector.get_face_mesh(frame) ────┐
   │                                            │
   │  DETECTOR PROCESSING:                      │
   │  ├─ Frame 0: RetinaFace.detect_faces()    │
   │  │  └─ Cache bbox in self.cached_bbox     │
   │  │                                         │
   │  ├─ EVERY frame: PFLD.detect_landmarks()  │
   │  │  └─ 68 points (68x2 array)             │
   │  │                                         │
   │  ├─ OPTIONAL: TargetedCLNFRefiner.refine()
   │  │  └─ Improve landmark accuracy          │
   │  │                                         │
   │  ├─ Quality check: check_landmark_quality()
   │  │  └─ If POOR: Try CLNFDetector.refine() │
   │  │                                         │
   │  ├─ Temporal smoothing:                   │
   │  │  ├─ Add to landmarks_history (max 5)   │
   │  │  └─ Weighted average (recent=higher)   │
   │  │                                         │
   │  └─ Return: smoothed_landmarks (68x2)    │
   │                                            │
   └─────────────────────────────────────────────┘

2. FaceMirror.create_mirrored_faces(frame, landmarks)
   ├─ Call: detector.get_facial_midline(landmarks)
   │  ├─ Get glabella (brow midpoint)
   │  └─ Get chin (lower anchor)
   ├─ Calculate perpendicular vector to midline
   ├─ Calculate signed distances for all pixels
   ├─ Create reflection map based on distances
   └─ Return: (right_face, left_face) [anatomically mirrored]

3. FaceMirror.create_debug_frame(frame, landmarks)
   ├─ Call: detector.get_facial_midline(landmarks)
   │  └─ Draw extended midline on frame
   ├─ Call: detector.calculate_head_pose(landmarks)
   │  └─ Display rotation warning (optimal/acceptable/excessive)
   └─ Return: debug_frame [for visualization]

FINAL OUTPUT:
├─ right_face: Right side of face mirrored to create full left side
├─ left_face: Left side of face mirrored to create full right side
└─ debug_frame: Original with anatomical midline and rotation warning

================================================================================
TEMPORAL SMOOTHING MECHANISM
================================================================================

5-FRAME HISTORY BUFFER:
├─ Maintains: landmarks_history (max 5 frames)
├─ Also maintains: glabella_history, chin_history, yaw_history
└─ All with history_size=5

WEIGHTED AVERAGING ALGORITHM:
├─ weights = np.linspace(0.5, 1.0, n_frames)
│  └─ Older frames: 0.5 weight
│  └─ Newer frames: 1.0 weight
├─ weights = weights / sum(weights)  # Normalize
└─ smoothed = sum(pts[i] * weights[i] for each frame i)

BENEFIT: Reduces temporal jitter while maintaining responsiveness
COST: First 5 frames have reduced smoothing (progressive increase)

================================================================================
QUALITY CONTROL MECHANISMS
================================================================================

LANDMARK QUALITY CHECKS (check_landmark_quality):
1. Clustering Detection
   ├─ Split landmarks by x-coordinate (left/right halves)
   ├─ Check ratio: max(left_count, right_count) / 68
   └─ Flag POOR if ratio > 0.75 (>75% landmarks on one side)

2. Spatial Distribution
   ├─ Calculate std of x and y coordinates
   ├─ Expected x_std = bbox_width * 0.25
   ├─ Expected y_std = bbox_height * 0.25
   └─ Flag POOR if below expected (landmarks too concentrated)

FALLBACK MECHANISM:
├─ IF landmarks are POOR quality:
│  ├─ AND clnf_fallback available:
│  │  ├─ Run CLNFDetector (slower but more accurate)
│  │  └─ WARN user: "ADVANCED LANDMARK REFINEMENT ACTIVATED"
│  └─ Otherwise: Use original landmarks
└─ Track poor frames for post-processing warning dialog

HEAD POSE QUALITY:
├─ Calculate yaw from symmetric landmark pairs
├─ Display warnings based on |yaw| thresholds:
│  ├─ OPTIMAL: |yaw| <= 3°
│  ├─ ACCEPTABLE: 3° < |yaw| <= 5°
│  └─ EXCESSIVE: |yaw| > 5°
└─ Helps users understand frame quality

================================================================================
PERFORMANCE CHARACTERISTICS
================================================================================

TIMING BREAKDOWN (per frame):
├─ RetinaFace detection: ~30ms (Frame 0 only, cached)
├─ PFLD landmarks: ~5-10ms
├─ SVR CLNF refinement: ~1-2ms (optional)
├─ Quality check: <1ms
├─ Temporal smoothing: <1ms
├─ Fallback CLNF: ~200-500ms (only poor frames)
└─ TOTAL (typical): 10-15ms per frame

FRAME RATE:
├─ Theoretical: ~70-100 FPS
├─ Actual: ~14-28 FPS on Apple Silicon
└─ Limited by: Video I/O, writing, not detection

MEMORY USAGE:
├─ 5-frame history per detector instance: ~5-10 MB
├─ Batch processing: 100 frames = ~1.2 GB (vs 32GB for all in memory)
└─ Model weights: ~10 MB total

================================================================================
CONFIGURATION OPTIONS
================================================================================

DETECTION SETTINGS (in face_splitter.py __init__):
├─ debug_mode: Enable verbose logging
├─ skip_redetection: Only run RetinaFace on frame 0
├─ skip_face_detection: Skip RetinaFace entirely (uses default bbox)
├─ use_clnf_refinement: Enable SVR-based CLNF (default: True)
└─ num_threads: Parallel frame processing threads (default: 6)

PERFORMANCE SETTINGS (in config.py):
├─ NUM_THREADS: Worker threads (default: 6)
├─ BATCH_SIZE: Frames per batch (default: 100)
├─ CONFIDENCE_THRESHOLD: Face detection (default: 0.5)
├─ NMS_THRESHOLD: Duplicate suppression (default: 0.4)
├─ OMP_NUM_THREADS: CPU threading (default: 2)
└─ GC_THRESHOLD: Garbage collection optimization

OPTIMIZATION TIPS:
├─ To speed up 2-3x: Set use_clnf_refinement=False
├─ To reduce memory: Lower BATCH_SIZE
├─ To improve detection: Lower confidence_threshold
├─ To skip detection: Set skip_face_detection=True (risky)

================================================================================
KEY FUNCTIONS TO MODIFY FOR CUSTOMIZATION
================================================================================

1. CHANGE LANDMARK DETECTION METHOD:
   └─ Modify: pyfaceau_detector.py, get_face_mesh() [Lines 270-426]
      └─ Replace PFLD with different detector

2. CHANGE ANATOMICAL MIDLINE CALCULATION:
   └─ Modify: pyfaceau_detector.py, get_facial_midline() [Lines 428-471]
      └─ Use different landmark indices or calculation

3. CHANGE HEAD POSE ESTIMATION:
   └─ Modify: pyfaceau_detector.py, calculate_head_pose() [Lines 473-543]
      └─ Use 3D model or different algorithm

4. CHANGE MIRRORING ALGORITHM:
   └─ Modify: face_mirror.py, create_mirrored_faces() [Lines 12-106]
      └─ Implement different reflection strategy

5. CHANGE FRAME PROCESSING LOOP:
   └─ Modify: video_processor.py, _process_frame_batch() [Lines 203-238]
      └─ Add preprocessing/postprocessing

6. ADD NEW QUALITY CHECKS:
   └─ Modify: pyfaceau_detector.py, check_landmark_quality() [Lines 186-245]
      └─ Add additional validation criteria

================================================================================
INTEGRATION POINTS
================================================================================

APPLICATION STARTUP (main.py):
├─ Line 763: Creates PyFaceAU68LandmarkDetector
├─ Passes to StableFaceSplitter
└─ Wrapped in try-catch for error handling

PIPELINE INITIALIZATION (face_splitter.py):
├─ Lines 16-56: __init__() creates all components
├─ Warmup: Lines 58-82 test models with dummy frame
└─ Freeze GC: Lines 78-79 prevent garbage collection

FRAME PROCESSING LOOP (video_processor.py):
├─ Lines 203-238: _process_frame_batch() for each frame
├─ Calls detector.get_face_mesh()
├─ Passes landmarks to face_mirror
└─ Handles errors gracefully

MIRRORING APPLICATION (face_mirror.py):
├─ Lines 12-106: create_mirrored_faces() uses landmarks
├─ Lines 22-23: Calls detector.get_facial_midline()
└─ Lines 163: Calls detector.calculate_head_pose()

================================================================================
GENERATED DOCUMENTATION
================================================================================

THREE NEW REFERENCE DOCUMENTS CREATED:

1. LANDMARK_DETECTION_GUIDE.md (500+ lines)
   └─ Comprehensive technical reference
      ├─ Detailed model descriptions
      ├─ Architecture diagrams
      ├─ Code flow explanations
      └─ Performance analysis

2. QUICK_REFERENCE.md (300+ lines)
   └─ Quick lookup guide
      ├─ File summary
      ├─ Key methods
      ├─ Landmark indices
      ├─ Troubleshooting
      └─ Testing procedures

3. FILE_RELATIONSHIPS.md (400+ lines)
   └─ Visual dependency maps
      ├─ Architecture diagram
      ├─ Data flow diagram
      ├─ File dependency table
      ├─ Critical sections
      └─ Error handling paths

ALL SAVED TO:
/Users/johnwilsoniv/Documents/SplitFace Open3/S1 Face Mirror/

================================================================================
CONCLUSIONS & RECOMMENDATIONS
================================================================================

CURRENT STATE:
✓ Working implementation using PyFaceAU (pure Python, no C++ deps)
✓ Real-time performance on Apple Silicon (~14-28 FPS)
✓ 68-point landmarks with temporal smoothing
✓ Automatic quality detection and fallback refinement
✓ Well-structured, modular codebase

AREAS FOR POTENTIAL MODIFICATION:
├─ Alternative landmark detector (currently PFLD)
├─ Different anatomical midline calculation
├─ 3D landmarks instead of 2D (1k3d68.onnx available)
├─ Different mirroring algorithm
├─ Enhanced quality checks for specific pathologies
└─ Custom head pose estimation

PERFORMANCE OPTIMIZATION OPPORTUNITIES:
├─ Disable CLNF refinement: 2-3x speedup
├─ Skip redetection: Minimal speedup (already cached)
├─ GPU acceleration: Currently uses CPU+CoreML
└─ Batch processing already optimized

ROBUSTNESS IMPROVEMENTS:
├─ Add 3D shape constraints for pathological cases
├─ Implement multi-face detection (currently single face)
├─ Add temporal consistency checks across frames
├─ Implement automatic face region trimming
└─ Add user-adjustable quality thresholds

================================================================================
END OF SUMMARY
================================================================================

For more details, see the three reference documents created:
- LANDMARK_DETECTION_GUIDE.md
- QUICK_REFERENCE.md
- FILE_RELATIONSHIPS.md

All located in: /Users/johnwilsoniv/Documents/SplitFace Open3/S1 Face Mirror/
